# CivicForge V2 -- Penetration Test Report

**Version:** 1.0
**Date:** 2026-02-07
**Tester:** Automated SAST + Manual Business Logic Audit
**Scope:** All server-side code, RLS policies, API routes, and client components
**Branch:** ws3/pentest
**Threat Model Reference:** docs/THREAT_MODEL.md (WS2)

---

## 1. Executive Summary

CivicForge V2 demonstrates a **strong security posture** for a community-focused application. The WS2 threat model correctly identified and mitigated the most critical vulnerabilities (V1-V6). The codebase consistently follows security best practices: `getUser()` is used everywhere instead of `getSession()`, all server actions validate inputs with Zod, user IDs are always derived from auth tokens, and RLS is enabled on every table.

This penetration test found **5 new vulnerabilities** (1 High, 2 Medium, 2 Low) beyond those already documented in the threat model. All 5 have been **fixed** as part of this workstream. The remaining known gap (V7: AI token budget not enforced) from the threat model is confirmed and documented as an accepted risk for V2 launch.

**Risk Summary:**
- **Critical:** 0 new (0 open)
- **High:** 1 new (fixed: audit log silent failure in unflagPost)
- **Medium:** 2 new (fixed: open redirect in auth callback, PostgREST filter injection)
- **Low:** 2 new (fixed: Math.random for invite codes, missing UUID validation on AI match route)
- **Info:** 3 observations documented

---

## 2. Methodology

### 2.1 Static Analysis (SAST)

Manual code audit equivalent to automated SAST, covering:

- **Auth pattern audit:** Searched all `app/actions/*.ts` (9 files) and `app/api/*/route.ts` (8 files) for `getSession()` usage, client-supplied user IDs, missing auth checks, and service role key exposure.
- **Input validation audit:** Verified Zod schema validation on every server action and API route input. Checked for raw SQL queries and injection vectors.
- **XSS vector audit:** Searched entire codebase for `dangerouslySetInnerHTML`, verified AI output sanitization path, and reviewed component rendering of user content.
- **Secret exposure audit:** Searched for `NEXT_PUBLIC_` prefixed env vars and verified no secrets appear in client-scoped code. Verified `SUPABASE_SERVICE_ROLE_KEY` and `ANTHROPIC_API_KEY` are server-only.
- **Cryptographic audit:** Checked random number generation for security-sensitive operations.

### 2.2 Business Logic Testing

Traced code paths for:
- Trust tier escalation (Tier 1 -> Tier 2 bypass)
- Rate limit bypass when Redis is unconfigured
- Flag manipulation (self-flag, double-flag, count manipulation)
- Review queue bypass for new accounts
- Invitation abuse (expired redemption, double-redemption, replay)
- Photo upload authorization and bucket configuration
- Open redirect vectors in auth flows

### 2.3 RLS Policy Review

Reviewed all 3 SQL migrations (0001, 0002, 0003) for:
- Overly permissive policies
- Missing policies
- USING/WITH CHECK consistency
- Service role vs. anon client usage alignment

---

## 3. Findings

### PT-01: Audit Log Insert Fails Silently in unflagPost (HIGH)

- **Severity:** HIGH
- **Description:** The `unflagPost()` function in `app/actions/flags.ts` used the anon-key Supabase client to insert into the `audit_log` table. However, the `audit_log_insert_service_role` RLS policy only allows `service_role` inserts. This means unflag audit entries were silently dropped, creating a gap in the audit trail for moderation actions.
- **Location:** `app/actions/flags.ts:116-121` (original)
- **Proof of Concept:** A Tier 3 admin calls `unflagPost()`. The flag is removed and the post is unhidden, but the audit_log insert fails silently because the anon client does not have the `service_role` role. There is no record of the moderation action.
- **Impact:** Complete loss of audit trail for unflag actions. An admin could unflag posts without accountability.
- **Remediation:** Import and use `createServiceClient()` for audit log inserts, consistent with the pattern already used in `admin.ts`.
- **Status:** **Fixed in WS3** -- Changed to `createServiceClient()` at line 116.

### PT-02: Open Redirect in Auth Callback (MEDIUM)

- **Severity:** MEDIUM
- **Description:** The OAuth callback at `app/api/auth/callback/route.ts` reads a `next` query parameter and redirects to it after successful authentication: `NextResponse.redirect(\`${origin}${next}\`)`. An attacker could craft a malicious link like `/api/auth/callback?code=...&next=//evil.com` which would redirect the user to `https://civicforge.org//evil.com` (which browsers resolve as `https://evil.com`). This is a classic open redirect vulnerability that can be used in phishing attacks.
- **Location:** `app/api/auth/callback/route.ts:7` (original)
- **Proof of Concept:** Attacker sends victim a link: `https://civicforge.org/api/auth/callback?code=VALID_CODE&next=//evil.com/phish`. After the user authenticates, they are redirected to the attacker's phishing page, which could mimic CivicForge to steal credentials or personal information.
- **Impact:** Phishing amplification -- attackers can abuse the legitimate domain to redirect users to malicious sites after authentication.
- **Remediation:** Validate the `next` parameter to ensure it starts with `/` and does not start with `//` (protocol-relative URL).
- **Status:** **Fixed in WS3** -- Added validation: `rawNext.startsWith("/") && !rawNext.startsWith("//")`, falling back to `/board`.

### PT-03: PostgREST Filter Injection in Community Search (MEDIUM)

- **Severity:** MEDIUM
- **Description:** The `searchCommunities()` function interpolates user-supplied search terms directly into a Supabase `.or()` filter string: `.or(\`name.ilike.%${searchTerm}%,city.ilike.%${searchTerm}%\`)`. PostgREST filter syntax uses characters like `.`, `,`, `(`, `)` as operators. A crafted search term containing these characters could manipulate the filter logic, potentially accessing data outside the intended query scope or causing unexpected errors.
- **Location:** `app/actions/communities.ts:207` (original)
- **Proof of Concept:** A user searches for `%,id.eq.` followed by a UUID. This could manipulate the filter to include an `id.eq.UUID` clause, bypassing the intended ilike search. While the impact is limited by RLS policies, the filter manipulation itself is a code injection vector.
- **Impact:** Potential filter manipulation. Limited by RLS policies and the communities table being readable by all authenticated users, but the pattern is a code smell that could be more dangerous on tables with stricter access controls.
- **Remediation:** Sanitize special PostgREST characters from search input before interpolation.
- **Status:** **Fixed in WS3** -- Added `searchTerm.replace(/[%_().,\\]/g, "")` sanitization.

### PT-04: Math.random() Used for Invite Code Generation (LOW)

- **Severity:** LOW
- **Description:** The `generateInviteCode()` function in `lib/utils.ts` used `Math.random()` to generate 8-character invitation codes. `Math.random()` is not cryptographically secure -- its output can be predicted if an attacker observes enough previous values. While the invite code space (31^8 = ~852 billion) provides reasonable entropy, the predictability of `Math.random()` reduces the effective security.
- **Location:** `lib/utils.ts:26` (original)
- **Proof of Concept:** An attacker who can observe multiple generated invite codes in sequence (e.g., by being a Tier 2 member and generating several codes) could potentially predict the PRNG state and guess future invite codes before they are shared with intended recipients.
- **Impact:** Low in practice because invite codes are single-use and expire in 7 days, but the use of a non-CSPRNG for security tokens is a code hygiene issue.
- **Remediation:** Replace `Math.random()` with `crypto.getRandomValues()`.
- **Status:** **Fixed in WS3** -- Replaced with `crypto.getRandomValues(new Uint8Array(8))`.

### PT-05: Missing UUID Validation on AI Match Route postId (LOW)

- **Severity:** LOW
- **Description:** The `POST /api/ai/match` route accepted a `postId` from the request body without validating it as a UUID format. While Supabase would reject a non-UUID value at the database level, passing unsanitized input to the query could cause unexpected error handling behavior.
- **Location:** `app/api/ai/match/route.ts:46-48` (original)
- **Proof of Concept:** Sending `{"postId": "not-a-uuid"}` would reach the Supabase query layer before being rejected, rather than being caught at input validation.
- **Impact:** Minimal -- Supabase rejects invalid UUIDs. But defense-in-depth requires validating input format before it reaches the database layer.
- **Remediation:** Add Zod UUID validation for the postId parameter.
- **Status:** **Fixed in WS3** -- Added `z.string().uuid().safeParse(postId)` check.

---

## 4. Business Logic Test Results

| # | Test Case | Result | Notes |
|---|-----------|--------|-------|
| BL-01 | Tier 1 user cannot create posts | **PASS** | Server-side check in `createPost()` at line 62; RLS `posts_insert_tier2` enforces `trust_tier >= 2` |
| BL-02 | Tier 1 user cannot create responses | **PASS** | Server-side check in `createResponse()` at line 45; RLS `responses_insert_tier2` enforces tier |
| BL-03 | Tier 1 user cannot create invitations | **PASS** | Server-side check in `createInvitation()` at line 33 |
| BL-04 | Tier check is server-side, not client-side | **PASS** | All tier checks query profiles table with auth.uid() in server actions |
| BL-05 | User cannot flag their own post | **PASS** | `flagPost()` line 38: `post.author_id === user.id` check |
| BL-06 | User cannot flag the same post twice | **PASS** | Application-level check at `flagPost()` line 42-51; DB-level `post_flags_post_user_uniq` unique index |
| BL-07 | Rate limits enforced on AI endpoints | **PASS** | Both `/api/ai/match` and `/api/ai/extract` check `ratelimit.limit(user.id)` |
| BL-08 | Rate limits bypassed when Redis unconfigured | **FAIL (Known Gap)** | Both routes set `ratelimit = null` when Redis URL is missing; requests proceed without rate limiting. Documented as V7 in threat model. |
| BL-09 | New account posts go through review queue | **PASS** | `createPost()` checks post count < `NEW_ACCOUNT_REVIEW_POST_COUNT` (3) and sets `review_status: "pending_review"` |
| BL-10 | Review queue cannot be bypassed by client | **PASS** | `review_status` is set server-side based on post count; not derived from client input |
| BL-11 | Expired invitations cannot be redeemed | **PASS** | `redeemInvitation()` line 131: `new Date(invitation.expires_at) < new Date()` check |
| BL-12 | Used invitations cannot be redeemed again | **PASS** | `redeemInvitation()` line 123: `invitation.used_by` check; RLS `invitations_update_redeem` USING clause: `used_by IS NULL` |
| BL-13 | Invitation RLS fix (0003) is correctly scoped | **PASS** | Two policies: creator update (USING `created_by = auth.uid()`) and redemption (USING `used_by IS NULL`, WITH CHECK `used_by = auth.uid()`) |
| BL-14 | Non-admin cannot access review/moderation functions | **PASS** | `requireTier3()` in `admin.ts` checks `trust_tier >= 3`; admin layout also checks tier server-side |
| BL-15 | User cannot respond to their own post | **PASS** | `createResponse()` line 67: `post.author_id === user.id` check |
| BL-16 | User cannot respond to the same post twice | **PASS** | Application-level check at line 75-87; DB-level `responses_post_responder_uniq` unique index |
| BL-17 | User cannot thank themselves | **PASS** | `createThanks()` line 35: `parsed.data.toUserId === user.id` check |
| BL-18 | Photo EXIF/GPS stripped before storage | **PASS** | `processPhoto()` uses Sharp `.rotate()` (auto-orient) then `.jpeg()` which strips all metadata |
| BL-19 | Photo moderation fails closed in production | **PASS** | `moderatePhoto()` returns `{ safe: false }` when API key missing in production |
| BL-20 | Post ownership verified before update/delete | **PASS** | `updatePost()` and `deletePost()` both verify `existing.author_id !== user.id` |
| BL-21 | Membership review restricted to same community | **PASS** | `reviewMembership()` line 158: `reviewerProfile.community_id !== request.community_id` check |

---

## 5. Positive Findings

The following security patterns are correctly and consistently implemented:

### 5.1 Authentication
- **`getUser()` used everywhere:** All 9 server action files and all 8 API route files use `supabase.auth.getUser()` for authentication. No usage of `getSession()` found outside of documentation comments warning against it.
- **User IDs derived from auth tokens:** Every server action derives the user ID from `user.id` (obtained via `getUser()`). No action accepts a user ID from client input for authorization purposes.
- **Service role key isolation:** `SUPABASE_SERVICE_ROLE_KEY` is only accessed in `lib/supabase/server.ts:35` and never appears in any `NEXT_PUBLIC_` prefixed variable or client-side code.

### 5.2 Input Validation
- **Zod schemas on all server actions:** Every server action validates input with Zod before processing. Schemas include string length limits, UUID format checks, and enum validation.
- **API route input validation:** All API routes validate request body contents (text length, file type, phone format).
- **UUID validation on IDs:** All server actions validate ID parameters with `z.string().uuid()`.
- **No raw SQL queries:** All database access uses the Supabase client library, which parameterizes queries. No raw SQL or string interpolation in query values.

### 5.3 XSS Prevention
- **No `dangerouslySetInnerHTML`:** Zero instances found in the entire codebase.
- **AI output sanitization:** All AI-generated text passes through `sanitizeOutput()` before being returned to clients. The function strips script tags, SVG, math, style, link, meta, base tags, event handlers, javascript: protocol, and CSS injection vectors.
- **React auto-escaping:** All components render user content via JSX expressions (`{variable}`), which React automatically escapes.
- **CSP headers:** Strict Content-Security-Policy with `frame-ancestors 'none'`, `base-uri 'self'`, `form-action 'self'`. No `unsafe-eval`.

### 5.4 Row Level Security
- **RLS enabled on all 14 tables** (13 original + post_flags).
- **Every table has appropriate policies** for SELECT, INSERT, UPDATE, and DELETE operations.
- **Service-role-only tables:** `ai_matches` and `audit_log` correctly restrict INSERT to `service_role` only.
- **Community isolation:** Posts, profiles, and related data are scoped to communities via RLS policies.

### 5.5 AI Security
- **Context isolation:** User text and matching logic never share an LLM context. Post extraction uses datamarked input; matching receives only structured fields.
- **Datamarking:** User text is word-level wrapped with `^` delimiters before entering AI prompts.
- **Sandwich defense:** System prompts repeat critical safety rules at both start and end.
- **Zod-validated output:** All AI responses are validated through strict Zod schemas via `generateObject()`.
- **Output sanitization:** AI-generated text fields are sanitized before being returned to the client.

### 5.6 Privacy
- **EXIF stripping:** Sharp strips all metadata from photos before storage, including GPS coordinates.
- **GPC detection:** Middleware detects the `Sec-GPC` header and sets `x-gpc-honored: true`.
- **No precise addresses:** Schema only stores `location_hint` (general area), and the AI extraction prompt explicitly prohibits precise addresses.
- **Data export/deletion:** GDPR-style data portability (export) and right-to-erasure (deletion with 30-day pipeline) are implemented.

---

## 6. Informational Observations

### INFO-01: Photo Upload Uses Service Client for Storage

- **Location:** `app/api/photos/upload/route.ts:54`
- **Observation:** The photo upload route uses `createServiceClient()` to upload to Supabase Storage, which bypasses the storage RLS policies that enforce folder-level access control (`(storage.foldername(name))[1] = auth.uid()::text`). The server constructs the path correctly using `user.id`, but if a bug were introduced that misaligned the path, the service client would not catch it.
- **Risk:** Low -- the path is constructed server-side from authenticated `user.id`.
- **Recommendation:** Consider using the anon client for storage uploads where possible, so that storage RLS provides a second layer of defense.

### INFO-02: Storage Bucket Name Mismatch

- **Location:** Migration `0001_initial_schema.sql:786` creates bucket `post-photos`; upload route `app/api/photos/upload/route.ts:62` references bucket `photos`.
- **Observation:** The bucket name in the upload route (`photos`) does not match the bucket created in the migration (`post-photos`). This could mean uploads fail in production, or a separate bucket was created manually.
- **Risk:** Operational -- could cause upload failures if the `photos` bucket does not exist in production.
- **Recommendation:** Align bucket names between migration and application code.

### INFO-03: Reputation Score Race Condition in Thanks

- **Location:** `app/actions/thanks.ts:80-86`
- **Observation:** The `createThanks()` function reads the recipient's current `reputation_score`, increments it by 1, and writes the new value. If two users send thanks to the same recipient concurrently, a race condition could cause one increment to be lost (classic read-modify-write race). Additionally, there is no DB-level unique constraint preventing a user from thanking the same person for the same post multiple times.
- **Risk:** Low -- the thanks table has no unique constraint on `(from_user, to_user, post_id)`, so reputation inflation is theoretically possible.
- **Recommendation:** Use a SQL `UPDATE profiles SET reputation_score = reputation_score + 1` pattern (or an RPC function) instead of read-modify-write. Consider adding a unique index on `(from_user, to_user, post_id)` to prevent duplicate thanks.

---

## 7. Threat Model Validation

All vulnerabilities identified in the WS2 threat model (V1-V7) were verified:

| ID | Description | Threat Model Status | Pentest Verification |
|----|-------------|--------------------|--------------------|
| V1 | CSP includes unsafe-eval | FIXED | Confirmed fixed. `script-src 'self' 'unsafe-inline'` -- no `unsafe-eval`. |
| V2 | AI match inserts use anon client | FIXED | Confirmed fixed. `createServiceClient()` used in match route. |
| V3 | Audit log inserts use anon client | FIXED | Confirmed fixed in `admin.ts`. **However, `flags.ts` had the same bug (PT-01), now also fixed.** |
| V4 | Invitation update policy USING (true) | FIXED | Confirmed fixed. Migration 0003 creates properly scoped policies. |
| V5 | Regex XSS sanitizer misses SVG/CSS | FIXED | Confirmed fixed. `sanitizeOutput()` now strips SVG, math, style, link, meta, base tags and CSS vectors. |
| V6 | Photo moderation fails open without API key | FIXED | Confirmed fixed. Production fails closed; development fails open. |
| V7 | AI token budget never enforced | KNOWN GAP | Confirmed. `AI_DAILY_TOKEN_BUDGET` defined but never checked. `increment_ai_usage()` is called in extract route but not in match route, and budget is not checked before requests. |

---

## 8. Recommendations (Prioritized)

### Priority 1 -- Before Production Launch
1. **Align storage bucket names** between migration (`post-photos`) and application code (`photos`) to prevent upload failures (INFO-02).
2. **Require Upstash Redis in production** -- fail the AI routes with 503 Service Unavailable when rate limiting is unconfigured, rather than silently disabling it (BL-08).

### Priority 2 -- Near-Term Hardening
3. **Replace regex sanitizer with DOMPurify** running server-side via jsdom for comprehensive XSS prevention (V5 note in threat model).
4. **Enforce AI token budget** -- check `ai_usage` table before AI requests and reject when budget is exceeded (V7).
5. **Add unique constraint on thanks** `(from_user, to_user, post_id)` to prevent reputation inflation (INFO-03).
6. **Use atomic increment for reputation_score** via `supabase.rpc()` to prevent race conditions (INFO-03).

### Priority 3 -- Future Improvements
7. **Add nonce-based CSP** to eliminate `unsafe-inline` from `style-src`.
8. **Add per-user rate limiting for Twilio** to prevent SMS flooding.
9. **Use anon client for storage uploads** to get double-layer RLS protection (INFO-01).
10. **Add request logging** for all service-role client usage to detect misuse.
11. **Consider content signing** for audit log entries to prevent tampering.

---

## 9. Files Modified in WS3

| File | Change |
|------|--------|
| `app/actions/flags.ts` | PT-01: Changed audit_log insert to use `createServiceClient()` |
| `app/api/auth/callback/route.ts` | PT-02: Added open redirect prevention on `next` parameter |
| `app/actions/communities.ts` | PT-03: Added PostgREST filter character sanitization in search |
| `lib/utils.ts` | PT-04: Replaced `Math.random()` with `crypto.getRandomValues()` |
| `app/api/ai/match/route.ts` | PT-05: Added Zod UUID validation for postId |
